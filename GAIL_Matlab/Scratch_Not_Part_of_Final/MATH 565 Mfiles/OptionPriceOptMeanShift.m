%Computing prices of Asian and American options%clear allglobal Normal_Sobol_Sequence%if ~exist('Normal_Sobol_Sequence','var'), load Normal_Sobol_Sequence_File.mat, end%% Parameter set-upsample.type='iid';   %iid = i.i.d. random sampling   %sobol =  a quasi-random sequencesample.N=100000; %number of stock pathssample.d=26; %number of trading periodssample.s=10; %number of eigenfunctions in Karhunen-Loevesample.T=1/2; %final time in yearssample.anti=false; %antithetic variables or not (a Boolean variable)sample.import=true; %importance sampling or not (a Boolean variable)sample.meanshift=.25; %shift of mean of normal random variableasset.modtype='dgbm';    %dgbm = discrete geometric Brownian motion   %cgbm =  Karuhnen-Loeve expansion   %stickydelta = dgbm with volatility smile   %jump = jump diffusion model   %vg =  variance gammaasset.s0=100; %initial priceasset.sig=0.5; %volatilityasset.sigskew=0; %quadratic coefficient for volatility smileasset.sigsmile=5; %quadratic coefficient for volatility smileasset.r=0.05; %interest rateasset.ljump=1.9; %intensity of the jump processasset.ajump=0; %mean of jump magnitudeasset.bjump=0.4; %spread of jump magnitudeasset.vgbeta=0.2; %fatness of variance gamma processasset.control={}; %control variates   %euro = European option for discrete Brownian motion with or without   %          jumps   %gmean = geometric mean option for discrete Brownian motion   %priceT = asset price at time Toption.type='amean';    %euro = European   %amer = American   %amean = Arithmetic mean   %gmean = Geometric mean   %upin = Up and In Barrier   %upout = Up and Out Barrier   %downin = Down and In Barrier   %downout = Down and Out Barrier   %look = Lookbackoption.exacttype={}; %eurogbm   %eurogbm = European with geometric Brownian motion   %eurojump = European with jump diffusioon process   %gmean = geometric mean with geometric Brownian motionoption.strike=100; %strike priceoption.barrier=70; %barriersample.Nvec=(1:sample.N)';sample.delt=sample.T/sample.d; %width of time interval sample.tvec=(0:sample.d)*sample.delt; %vector of time valueswhe=strcmp('euro',asset.control);whg=strcmp('gmean',asset.control);if strcmp('dgbm',asset.modtype);     if any(whe); asset.control(whe)={'eurogbm'}; endelseif strcmp('jump',asset.modtype)    if any(whe); asset.control(whe)={'eurojump'}; end    if any(whg); asset.control(whg)=''; end %can't do geometric mean exactly for non-dgbmelse    if any(whe); asset.control(whe)=''; end %can't do European mean exactly for non-dgbm    if any(whg); asset.control(whg)=''; end %can't do geometric mean exactly for non-dgbmendif numel(option.exacttype)>0;    exprice=exactprice(sample,asset,option);end%% Initialize intervalleft=0;right=1;gold=(sqrt(5)-1)/2;%% Initialize objective functionsample.meanshift=left;[smat,sample,asset]=samplepath(sample,asset,option);[pay,option]=payoff(smat,sample,asset,option);price=optprice(pay,sample,asset,option);lefterr=price.callerr;sample.meanshift=right;[smat,sample,asset]=samplepath(sample,asset,option);[pay,option]=payoff(smat,sample,asset,option);price=optprice(pay,sample,asset,option);righterr=price.callerr;%% Loop%if miderr>max(lefterr,righterr); disp('Bad interval'); endwhile (right-left)/max(abs(left),abs(right)) > 0.1;    disp([left right]);    mid=left+gold*(right-left);    sample.meanshift=mid;    [smat,sample,asset]=samplepath(sample,asset,option);    [pay,option]=payoff(smat,sample,asset,option);    price=optprice(pay,sample,asset,option);    miderr=price.callerr;     if lefterr<miderr;        right=mid;        righterr=miderr;    elseif righterr<miderr;        left=mid;        lefterr=miderr;    else        mid1=right+gold*(left-right);        sample.meanshift=mid1;        [smat,sample,asset]=samplepath(sample,asset,option);        [pay,option]=payoff(smat,sample,asset,option);        price=optprice(pay,sample,asset,option);        mid1err=price.callerr;        if miderr<mid1err;            left=mid1;            lefterr=mid1err;        else            right=mid;            righterr=miderr;         end    endend                        