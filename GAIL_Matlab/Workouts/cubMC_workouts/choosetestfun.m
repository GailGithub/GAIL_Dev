function [testfun,out_param]=choosetestfun(fun,in_param)
%CHOOSETESTFUN Chooses and sets up a test function
%      from the parameters input by the user and contained in the
%      structures fun and in_param
%   fun.funtype            = type of test function
%   fun.shape              = shape parameter (1 x param.dim)
%   fun.scale              = scale parameter (1 x param.dim)
%   fun.addc               = additive constant (1 x param.dim)
%   fun.overaddc           = overall additive constant (scalar)
%   fun.overmultc          = overall multiplicative constant (scalar)
%   in_param.interval      = domain of test function
%   in_param.dim           = dimension of the domain
%   in_param.measure       = probability density function for integration
%   in_param.exactintegral = exact value of the integral (scalar)

if nargin < 2; %give the basic default parameters 
    in_param.interval=[0;1]; %default integration interval
    if nargin < 1; fun.funtype='exp'; end %exponential test function
end
if ~isfield(in_param,'interval'); in_param.interval=[0;1]; end %default interval

%[~,in_param,out_param]=cubMC_g_param([],in_param,'fun'); %check validity of some parameters

if strcmp(fun.funtype,'exp') %exponential test function
    [testfun,out_param]=makeExpTestFun(fun,in_param);
elseif strcmp(fun.funtype,'step') %square step test function
    [testfun,out_param]=makeStepTestFun(fun,in_param);
elseif strcmp(fun.funtype,'gaussian')
    [testfun,out_param]=makeGaussianTestFun(fun,in_param);
else
    error('Function type not recognized')
end

in_param.fun=fun; %copy of the function parameters
end

%% Exponential Test Function
function [testfun,out_param]=makeExpTestFun(fun,in_param)
%Create the exponential test function
fun=verifyparam(fun,{'shape','scale','addc','overaddc','overmultc'}, ...
    {[1 in_param.dim],[1 in_param.dim],[1 in_param.dim],[1 1],[1 1]}, ...
    {1,1,0,0,1});
testfun=@(x) expfun(x,fun.overaddc,fun.overmultc,fun.addc,fun.scale,...
    fun.shape);

%% Compute exact integral of this function
if strcmp(in_param.measure,'uniform')
    bmina=in_param.interval(2,:)-in_param.interval(1,:);
    
    out_param.exactintegral=fun.overaddc*prod(bmina) + ...
        fun.overmultc.*prod(fun.addc.*bmina+fun.scale.*(exp(fun.shape ...
        .*in_param.interval(2,:))-exp(fun.shape.*in_param.interval(1,:)))./fun.shape);
    
    out_param.exactmean=fun.overaddc+ fun.overmultc.*prod(fun.addc ...
        + fun.scale.*(exp(fun.shape*diag(in_param.interval(2,:))) ...
        - exp(fun.shape*diag(in_param.interval(1,:))))./(fun.shape*diag(bmina)));
    
    out_param.moment1=fun.overmultc.*prod(fun.addc ...
        + fun.scale.*(exp(fun.shape*diag(in_param.interval(2,:))) ...
        - exp(fun.shape*diag(in_param.interval(1,:))))./(fun.shape*diag(bmina)));
    
    out_param.moment2=fun.overmultc.^2.*...
        prod(fun.addc.^2+2*fun.addc.*fun.scale.*...
        (exp(fun.shape*diag(in_param.interval(2,:))) ...
        - exp(fun.shape*diag(in_param.interval(1,:))))./(fun.shape*diag(bmina))+fun.scale.^2.*...
        (exp(2*fun.shape*diag(in_param.interval(2,:))) ...
        - exp(2*fun.shape*diag(in_param.interval(1,:))))./(2*fun.shape*diag(bmina)));
  
    out_param.exactvariance=out_param.moment2-out_param.moment1.^2;
    
    out_param.moment3=fun.overmultc.^3.*prod(fun.addc.^3+...
        3*fun.addc.^2.*fun.scale.*(exp(fun.shape*diag(in_param.interval(2,:))) ...
        - exp(fun.shape*diag(in_param.interval(1,:))))./(fun.shape*diag(bmina))+...
        3*fun.addc.*fun.scale.^2.*(exp(2*fun.shape*diag(in_param.interval(2,:))) ...
        - exp(2*fun.shape*diag(in_param.interval(1,:))))./(2*fun.shape*diag(bmina))+...
        fun.scale.^3.*(exp(3*fun.shape*diag(in_param.interval(2,:))) ...
        - exp(3*fun.shape*diag(in_param.interval(1,:))))./(3*fun.shape*diag(bmina)));
    
    out_param.moment4=fun.overmultc.^4.*prod(fun.addc.^4+...
        4*fun.addc.^3.*fun.scale.*(exp(fun.shape*diag(in_param.interval(2,:))) ...
        - exp(fun.shape*diag(in_param.interval(1,:))))./(fun.shape*diag(bmina))+...
        6*fun.addc.^2.*fun.scale.^2.*(exp(2*fun.shape*diag(in_param.interval(2,:))) ...
        - exp(2*fun.shape*diag(in_param.interval(1,:))))./(2*fun.shape*diag(bmina))+...
        4*fun.addc.*fun.scale.^3.*(exp(3*fun.shape*diag(in_param.interval(2,:))) ...
        - exp(3*fun.shape*diag(in_param.interval(1,:))))./(3*fun.shape*diag(bmina))+...
        fun.scale.^4.*(exp(4*fun.shape*diag(in_param.interval(2,:))) ...
        - exp(4*fun.shape*diag(in_param.interval(1,:))))./(4*fun.shape*diag(bmina)));
    
    out_param.exactkurtosis=(out_param.moment4-4*out_param.moment1...
        .*out_param.moment3+6*out_param.moment1.^2.*out_param.moment2...
        -4*out_param.moment1.^4+out_param.moment1.^4)...
        ./(out_param.exactvariance.^2);
    
    
else %normal distribution
    out_param.exactintegral=fun.overaddc ...
        + fun.overmultc.*prod(fun.addc ...
        + fun.scale.*exp(fun.shape.^2/2));
    exactintegralminus=fun.overmultc.*prod(fun.addc ...
        + fun.scale.*exp(fun.shape.^2/2));
    moment2=fun.overmultc.^2.*prod(fun.addc.^2 ...
        + 2.*fun.addc.*fun.scale.*exp(fun.shape.^2/2)...
        + fun.scale.^2.*exp((2*fun.shape).^2/2));
    moment3=fun.overmultc.^3.*prod(fun.addc.^3 ...
        + 3.*fun.addc.^2.*fun.scale.*exp(fun.shape.^2/2)...
        + 3*fun.addc.*fun.scale.^2.*exp((2*fun.shape).^2/2)...
        +fun.scale.^3.*exp((3*fun.shape).^2/2));
    moment4=fun.overmultc.^4.*prod(fun.addc.^4 ...
        + 4.*fun.addc.^3.*fun.scale.*exp(fun.shape.^2/2)...
        + 6*fun.addc.^2.*fun.scale.^2.*exp((2*fun.shape).^2/2)...
        +fun.addc.*fun.scale.^3.*exp((3*fun.shape).^2/2)...
        +fun.scale.^4.*exp(4*fun.shape).^2/2);
    out_param.exactvariance=moment2-exactintegralminus.^2;
      out_param.exactkurtosis=(moment4-4*exactintegralminus...
        .*moment3+6*exactintegralminus.^2.*moment2...
        -4*exactintegralminus.^4+exactintegralminus.^4)...
        ./(out_param.exactvariance.^2);
    
end

%% Prepare text description of the exponential function
if fun.overaddc==0; 
    formulastring='';
else
    formulastring=[num2str(fun.overaddc) ' + ']; 
end
if fun.overmultc~=1; 
    formulastring=[formulastring num2str(fun.overmultc) ' ']; 
end
if in_param.dim~=1; 
    formulastring=[formulastring 'prod_{j=1}^' int2str(in_param.dim)];
end
formulastring=[formulastring '['];
numdim=min(6,in_param.dim);
if in_param.dim<=numdim
    paramendstring=char(10); 
else
    paramendstring=[' ...' char(10)];
end
if fun.addc==0; 
    paramstring='';
else
    formulastring=[formulastring 'a_j + '];
    paramstring=['    a_j = ' num2str(fun.addc(1:numdim),'%6.3g')...
        paramendstring]; 
end
if fun.scale~=1; 
    formulastring=[formulastring 'b_j']; 
    paramstring=[paramstring ...
        '    b_j = ' num2str(fun.scale(1:numdim),'%6.3g')...
        paramendstring]; 
end
if fun.shape==1; 
    formulastring=[formulastring 'exp(x_j)'];
else
    formulastring=[formulastring 'exp(c_j x_j)'];
    paramstring=[paramstring ...
        '    c_j = ' num2str(fun.shape(1:numdim),'%6.3g')...
        paramendstring]; 
end
in_param.funDescribe=['   f(x) = ' formulastring ']' char(10) paramstring];
end

function f=expfun(x,overaddc,overmultc,addc,scale,shape)
    n=size(x,1);
    f=overaddc+overmultc.*prod(repmat(addc,n,1) ...
        + repmat(scale,n,1).*exp(repmat(shape,n,1).*x),2);
end

%% Step Test Function
function [testfun,out_param]=makeStepTestFun(fun,in_param)
%Create the exponential test function
fun=verifyparam(fun,{'shift','shape','scale','addc',...
    'overaddc','overmultc'}, ...
    {[1 in_param.dim],[1 in_param.dim],[1 in_param.dim],[1 in_param.dim],...
    [1 1],[1 1]}, ...
    {0.5,0.5,1,1,0,0});
bmina=in_param.interval(2,:)-in_param.interval(1,:);
testfun=@(x) stepfun(x,fun.overaddc,fun.overmultc,fun.addc,fun.scale,...
    fun.shape,fun.shift,bmina);

%% Compute exact integral of this function
%   as well as the variance and kurtosis
if strcmp(in_param.measure,'uniform')
    prodbmina=prod(bmina);
    moment1pc=fun.addc.*bmina+fun.scale.*fun.shape;
    moment2pc=(fun.addc.^2).*bmina+(2.*fun.addc+fun.scale)...
        .*fun.scale.*fun.shape;
    moment3pc=(fun.addc.^3).*bmina+(3.*(fun.addc.^2)...
        +fun.scale.*(3.*fun.addc+fun.scale)).*fun.scale.*fun.shape;
    moment4pc=(fun.addc.^4).*bmina+(4.*(fun.addc.^3)...
        +fun.scale.*(6.*(fun.addc.^2)+fun.scale.*(4.*fun.addc...
        +fun.scale))).*fun.scale.*fun.shape;
    
    moment1=prod(moment1pc);
    moment2=prod(moment2pc);
    moment3=prod(moment3pc);
    moment4=prod(moment4pc);
    out_param.exactintegral=fun.overaddc.*prodbmina + fun.overmultc.*moment1;
    out_param.exactvariance=(fun.overmultc.^2).*(moment2./prodbmina...
        -moment1.^2./(prodbmina)^2);
    out_param.exactkurtosis=(fun.overmultc.^4).*(...
        moment4./prodbmina+moment1.*(-4*moment3./(prodbmina)^2 ...
    +moment1.*(6*moment2./(prodbmina)^3 ...
        -3*moment1.^2./(prodbmina)^4)))./(out_param.exactvariance.^2);
    %keyboard
end

%% Prepare text description of the step function
if fun.overaddc==0; 
    formulastring='';
else
    formulastring=[num2str(fun.overaddc) ' + ']; 
end
if fun.overmultc~=1; 
    formulastring=[formulastring num2str(fun.overmultc) ' ']; 
end
if in_param.dim~=1; 
    formulastring=[formulastring 'prod_{j=1}^' int2str(in_param.dim)];
end
formulastring=[formulastring '['];
numdim=min(6,in_param.dim);
if in_param.dim<=numdim
    paramendstring=char(10); 
else
    paramendstring=[' ...' char(10)];
end
if fun.addc==0; 
    paramstring='';
else
    formulastring=[formulastring 'a_j + '];
    paramstring=['    a_j = ' num2str(fun.addc(1:numdim),'%6.3g')...
        paramendstring]; 
end
if fun.scale~=1; 
    formulastring=[formulastring 'b_j']; 
    paramstring=[paramstring ...
        '    b_j = ' num2str(fun.scale(1:numdim),'%6.3g')...
        paramendstring]; 
end
formulastring=[formulastring ...
    'Indicator_[0,p_j](x - z_j mod(up_j-lo_j)+lo_j'];
paramstring=[paramstring ...
    '    p_j = ' num2str(fun.shape(1:numdim),'%6.3g') paramendstring ...
    '    z_j = ' num2str(fun.shift(1:numdim),'%6.3g') paramendstring ...
    '    lo_j = ' num2str(in_param.interval(1,1:numdim),'%6.3g') ...
    paramendstring...
    '    hi_j = ' num2str(in_param.interval(2,1:numdim),'%6.3g') ...
    paramendstring]; 
in_param.funDescribe=['   f(x) = ' formulastring ']' char(10) paramstring];
end

function f=stepfun(x,overaddc,overmultc,addc,scale,shape,shift,bmina)
    n=size(x,1);
    f=overaddc+overmultc.*prod(repmat(addc,n,1) ...
        + repmat(scale,n,1)...
        .* (mod(x-repmat(shift,n,1),repmat(bmina,n,1))...
        <=repmat(shape,n,1)),2);
end
%% Gaussian Function
function [testfun,out_param]=makeGaussianTestFun(fun,in_param)
%Create the exponential test function
fun=verifyparam(fun,{'shape','scale','addc','overaddc','overmultc','center'}, ...
    {[1 in_param.dim],[1 in_param.dim],[1 in_param.dim],[1 1],[1 1],[1 in_param.dim]}, ...
    {1,1,0,0,1,0.5});
testfun=@(x) gaussianfun(x,fun.overaddc,fun.overmultc,fun.addc,fun.scale,...
    fun.shape,fun.center);

%% Compute exact integral of this function
if strcmp(in_param.measure,'uniform')
    bmina=in_param.interval(2,:)-in_param.interval(1,:);
    
    out_param.gaussian1=sqrt(pi)*fun.shape./(2*bmina).*...
        (erf((in_param.interval(2,:)-fun.center)...
        ./fun.shape)-erf((in_param.interval(1,:)-fun.center)./fun.shape));
    
    out_param.gaussian2=sqrt(pi)*fun.shape./(2*sqrt(2)*bmina).*...
        (erf(sqrt(2)*(in_param.interval(2,:)-fun.center)...
        ./fun.shape) - erf(sqrt(2)*(in_param.interval(1,:)-fun.center)./fun.shape));
    out_param.gaussian3=sqrt(pi)*fun.shape./(2*sqrt(3)*bmina).*...
        (erf(sqrt(3)*(in_param.interval(2,:)-fun.center)...
        ./fun.shape) - erf(sqrt(3)*(in_param.interval(1,:)-fun.center)./fun.shape));
    out_param.gaussian4=sqrt(pi)*fun.shape./(2*2*bmina).*...
        (erf(2*(in_param.interval(2,:)-fun.center)...
        ./fun.shape) - erf(2*(in_param.interval(1,:)-fun.center)./fun.shape));
    out_param.exactintegral=fun.overaddc.*prod(bmina)+ fun.overmultc.*prod(fun.addc ...
        .*bmina + fun.scale.*out_param.gaussian1.*bmina);
    
    out_param.exactmean=fun.overaddc+ fun.overmultc.*prod(fun.addc ...
        + fun.scale.*out_param.gaussian1);    
    
    out_param.moment1=fun.overmultc.*prod(fun.addc ...
        + fun.scale.*out_param.gaussian1);
    
    out_param.moment2=(fun.overmultc.^2.*...
        prod(fun.addc.^2+2*fun.addc.*fun.scale.*out_param.gaussian1...
        +fun.scale.^2.*out_param.gaussian2));
  
    out_param.exactvariance=out_param.moment2-out_param.moment1.^2;
    
    out_param.moment3=(fun.overmultc.^3.*prod(fun.addc.^3+...
        3*fun.addc.^2.*fun.scale.*out_param.gaussian1+...
        3*fun.addc.*fun.scale.^2.*out_param.gaussian2+...
        fun.scale.^3.*out_param.gaussian3));
    
    out_param.moment4=(fun.overmultc.^4.*prod(fun.addc.^4+...
        4*fun.addc.^3.*fun.scale.*out_param.gaussian1+...
        6*fun.addc.^2.*fun.scale.^2.*out_param.gaussian2+...
        4*fun.addc.*fun.scale.^3.*out_param.gaussian3+...
        fun.scale.^4.*out_param.gaussian4));
    
    out_param.exactkurtosis=(out_param.moment4-4*out_param.moment1...
        .*out_param.moment3+6*out_param.moment1.^2.*out_param.moment2...
        -4*out_param.moment1.^4+out_param.moment1.^4)...
        ./(out_param.exactvariance.^2);
    
    
else %normal distribution
    out_param.exactintegral=fun.overaddc ...
        + fun.overmultc.*prod(fun.addc ...
        + fun.scale.*exp(fun.shape.^2/2));
    exactintegralminus=fun.overmultc.*prod(fun.addc ...
        + fun.scale.*exp(fun.shape.^2/2));
    fminusint2=fun.overmultc.^2.*prod(fun.addc.^2 ...
        + 2.*fun.addc.*fun.scale.*exp(fun.shape.^2/2)...
        + fun.scale.^2.*exp((2*fun.shape).^2/2));
    fminusint3=fun.overmultc.^3.*prod(fun.addc.^3 ...
        + 3.*fun.addc.^2.*fun.scale.*exp(fun.shape.^2/2)...
        + 3*fun.addc.*fun.scale.^2.*exp((2*fun.shape).^2/2)...
        +fun.scale.^3.*exp((3*fun.shape).^2/2));
    fminusint4=fun.overmultc.^4.*prod(fun.addc.^4 ...
        + 4.*fun.addc.^3.*fun.scale.*exp(fun.shape.^2/2)...
        + 6*fun.addc.^2.*fun.scale.^2.*exp((2*fun.shape).^2/2)...
        +fun.addc.*fun.scale.^3.*exp((3*fun.shape).^2/2)...
        +fun.scale.^4.*exp(4*fun.shape).^2/2);
    out_param.exactvariance=fminusint2-exactintegralminus.^2;
      out_param.exactkurtosis=(fminusint4-4*exactintegralminus...
        .*fminusint3+6*exactintegralminus.^2.*fminusint2...
        -4*exactintegralminus.^4+exactintegralminus.^4)...
        ./(out_param.exactvariance.^2);
    
end

%% Prepare text description of the exponential function
if fun.overaddc==0; 
    formulastring='';
else
    formulastring=[num2str(fun.overaddc) ' + ']; 
end
if fun.overmultc~=1; 
    formulastring=[formulastring num2str(fun.overmultc) ' ']; 
end
if in_param.dim~=1; 
    formulastring=[formulastring 'prod_{j=1}^' int2str(in_param.dim)];
end
formulastring=[formulastring '['];
numdim=min(6,in_param.dim);
if in_param.dim<=numdim
    paramendstring=char(10); 
else
    paramendstring=[' ...' char(10)];
end
if fun.addc==0; 
    paramstring='';
else
    formulastring=[formulastring 'a_j + '];
    paramstring=['    a_j = ' num2str(fun.addc(1:numdim),'%6.3g')...
        paramendstring]; 
end
if fun.scale~=1; 
    formulastring=[formulastring 'b_j']; 
    paramstring=[paramstring ...
        '    b_j = ' num2str(fun.scale(1:numdim),'%6.3g')...
        paramendstring]; 
end
if fun.center~=0;
    formulastring=[formulastring 'H_j'];
    paramstring=[paramstring 'H_j = '...
        num2str(fun.center(1:numdim),'%6.3g ') paramendstring];
if fun.shape==1; 
    formulastring=[formulastring 'exp(-(x_j-H_j)^2)'];
else
    formulastring=[formulastring 'exp(-(x_j-H_j)^2/c_j^2)'];
    paramstring=[paramstring ...
        '    c_j = ' num2str(fun.shape(1:numdim),'%6.3g')...
        paramendstring]; 
end
in_param.funDescribe=['   f(x) = ' formulastring ']' char(10) paramstring];
end
end

function f=gaussianfun(x,overaddc,overmultc,addc,scale,shape,center)
    n=size(x,1);
    f=overaddc+overmultc.*prod(repmat(addc,n,1) ...
        + repmat(scale,n,1).*exp(-(x-repmat(center,n,1)).^2./repmat(shape.^2,n,1)),2);
end    

%% Brownian Motion Function
    

